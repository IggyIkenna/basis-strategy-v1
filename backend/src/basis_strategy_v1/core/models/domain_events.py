"""
Domain Event Models - Pydantic Models for Event Logging

This module defines all domain event models for comprehensive JSONL logging.
These events capture the complete state and history of the system for debugging
and analysis.

Reference: docs/LOGGING_GUIDE.md - Domain Event Schemas
Reference: docs/REFERENCE_ARCHITECTURE_CANONICAL.md - Observability Architecture
"""

from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Any
from datetime import datetime


class PositionSnapshot(BaseModel):
    """
    Position snapshot at a specific point in time.
    
    Logged by: PositionMonitor
    File: logs/{correlation_id}/{pid}/events/positions.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Position data
    positions: Dict[str, float] = Field(..., description="position_key -> amount")
    total_value_usd: float = Field(..., description="Total portfolio value in USD")
    position_type: str = Field(..., description="'simulated' or 'real'")
    
    # Metadata
    trigger_source: Optional[str] = Field(None, description="What triggered this snapshot")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class ExposureSnapshot(BaseModel):
    """
    Exposure calculation at a specific point in time.
    
    Logged by: ExposureMonitor
    File: logs/{correlation_id}/{pid}/events/exposures.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Exposure data
    net_delta_usd: float = Field(..., description="Net delta exposure in USD")
    asset_exposures: Dict[str, Dict[str, float]] = Field(
        ..., 
        description="asset -> {quantity, usd_value, percentage}"
    )
    total_value_usd: float = Field(..., description="Total portfolio value")
    share_class_value: float = Field(..., description="Value in share class currency")
    
    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class RiskAssessment(BaseModel):
    """
    Risk assessment at a specific point in time.
    
    Logged by: RiskMonitor
    File: logs/{correlation_id}/{pid}/events/risk_assessments.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Risk metrics
    health_factor: Optional[float] = Field(None, description="AAVE health factor")
    ltv_ratio: Optional[float] = Field(None, description="Loan-to-value ratio")
    liquidation_threshold: Optional[float] = Field(None, description="Liquidation threshold")
    margin_usage: Optional[float] = Field(None, description="CEX margin usage")
    risk_level: str = Field(..., description="'low', 'medium', 'high', 'critical'")
    
    # Warnings and breaches
    warnings: List[str] = Field(default_factory=list, description="Risk warnings")
    breaches: List[str] = Field(default_factory=list, description="Risk limit breaches")
    
    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class PnLCalculation(BaseModel):
    """
    P&L calculation at a specific point in time.
    
    Logged by: PnLCalculator
    File: logs/{correlation_id}/{pid}/events/pnl_calculations.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # P&L data
    realized_pnl: float = Field(..., description="Realized P&L")
    unrealized_pnl: float = Field(..., description="Unrealized P&L")
    total_pnl: float = Field(..., description="Total P&L (realized + unrealized)")
    fees_paid: float = Field(..., description="Total fees paid")
    funding_received: float = Field(..., description="Funding/interest received")
    
    # Attribution
    pnl_by_venue: Dict[str, float] = Field(default_factory=dict, description="P&L by venue")
    pnl_by_asset: Dict[str, float] = Field(default_factory=dict, description="P&L by asset")
    
    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class OrderEvent(BaseModel):
    """
    Order generated by strategy.
    
    Logged by: StrategyManager
    File: logs/{correlation_id}/{pid}/events/orders.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Order identification
    order_id: str = Field(..., description="Unique order ID (same as operation_id)")
    operation_id: str = Field(..., description="Operation identifier")
    
    # Order details
    operation_type: str = Field(..., description="Operation type (SPOT_TRADE, SUPPLY, etc.)")
    venue: str = Field(..., description="Target venue")
    source_venue: str = Field(..., description="Source venue")
    target_venue: str = Field(..., description="Target venue")
    source_token: str = Field(..., description="Source token")
    target_token: str = Field(..., description="Target token")
    amount: float = Field(..., description="Order amount")
    
    # Expected results
    expected_deltas: Dict[str, float] = Field(..., description="Expected position deltas")
    
    # Strategy context
    strategy_intent: Optional[str] = Field(None, description="Strategy intent (entry_full, exit_partial, etc.)")
    strategy_id: Optional[str] = Field(None, description="Strategy identifier")
    
    # Atomic grouping
    atomic_group_id: Optional[str] = Field(None, description="Atomic group ID if part of group")
    sequence_in_group: Optional[int] = Field(None, description="Sequence within atomic group")
    
    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class OperationExecutionEvent(BaseModel):
    """
    Comprehensive operation execution event for ALL operation types.
    
    This is the rich logging format - captures everything about an execution
    for debugging and analysis. Contrast with ExecutionHandshake which is
    the simple runtime format.
    
    Logged by: ExecutionManager
    File: logs/{correlation_id}/{pid}/events/operation_executions.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Core execution data
    operation_id: str = Field(..., description="Unique operation identifier")
    order_id: str = Field(..., description="Original order ID (links to OrderEvent)")
    operation_type: str = Field(..., description="Operation type (SPOT_TRADE, SUPPLY, etc.)")
    venue: str = Field(..., description="Target venue where operation executed")
    status: str = Field(..., description="Execution status (confirmed, failed, pending, rolled_back)")
    
    # Token flow details
    source_venue: str = Field(..., description="Source venue")
    target_venue: str = Field(..., description="Target venue")
    source_token: str = Field(..., description="Token being sent")
    target_token: str = Field(..., description="Token being received")
    
    # Operation-specific data (flexible per operation type)
    operation_details: Dict[str, Any] = Field(
        ..., 
        description="Operation-specific parameters (price, slippage, indexes, rates, etc.)"
    )
    # Examples:
    # SPOT_TRADE: {pair: "BTC/USDT", side: "BUY", price: 50000, slippage: 0.001}
    # SUPPLY: {token_in: "USDT", token_out: "aUSDT", aave_index: 1.05, health_factor: 2.5}
    # STAKE: {token_in: "ETH", token_out: "weETH", staking_rate: 0.04, conversion_rate: 1.02}
    # TRANSFER: {source_venue: "wallet", target_venue: "binance", token: "USDT", transfer_type: "deposit"}
    # FLASH_BORROW: {token: "WETH", flash_fee_bps: 9, repayment_amount: 10.009}
    
    # Position impacts (structured format for analysis)
    position_deltas: List[Dict[str, Any]] = Field(
        ...,
        description="List of position deltas with context"
    )
    # Example: [
    #   {position_key: "binance:BaseToken:BTC", delta_amount: 0.5, source: "spot_trade", price: 50000, fee: 0.0},
    #   {position_key: "binance:BaseToken:USDT", delta_amount: -25025.0, source: "spot_trade", price: 50000, fee: 25.0}
    # ]
    
    # Execution results
    executed_amount: float = Field(..., description="Actually executed amount")
    fee_amount: float = Field(..., description="Execution fee amount")
    fee_currency: str = Field(..., description="Fee currency")
    
    # Error handling
    error_code: Optional[str] = Field(None, description="Error code if execution failed")
    error_message: Optional[str] = Field(None, description="Error message if execution failed")
    
    # Atomic grouping
    atomic_group_id: Optional[str] = Field(None, description="Atomic group ID if part of group")
    sequence_in_group: Optional[int] = Field(None, description="Sequence within atomic group")
    
    # Timing
    submitted_at: datetime = Field(..., description="When operation was submitted")
    executed_at: Optional[datetime] = Field(None, description="When operation was executed")
    execution_time_ms: Optional[float] = Field(None, description="Execution duration in milliseconds")
    
    # Venue-specific metadata
    venue_metadata: Dict[str, Any] = Field(default_factory=dict, description="Venue-specific details")
    
    # Mode indicator
    simulated: bool = Field(False, description="True if backtest, False if live")
    
    # Additional metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class AtomicOperationGroupEvent(BaseModel):
    """
    Atomic group execution event (flash loans, complex DeFi operations).
    
    Tracks a group of operations that must execute atomically (all or nothing).
    The atomicity is guaranteed by the blockchain/venue, not by our code.
    
    Logged by: ExecutionManager
    File: logs/{correlation_id}/{pid}/events/atomic_operation_groups.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Group identification
    atomic_group_id: str = Field(..., description="Unique atomic group identifier")
    
    # Group composition
    total_operations: int = Field(..., description="Total number of operations in group")
    operations: List[Dict[str, Any]] = Field(
        ...,
        description="List of operation references and summaries"
    )
    # Example: [
    #   {operation_id: "flash_borrow_001", operation_type: "FLASH_BORROW", status: "confirmed"},
    #   {operation_id: "supply_001", operation_type: "SUPPLY", status: "confirmed"},
    #   {operation_id: "flash_repay_001", operation_type: "FLASH_REPAY", status: "confirmed"}
    # ]
    
    # Group status
    group_status: str = Field(
        ..., 
        description="Group status: 'completed', 'partial', 'failed', 'rolled_back'"
    )
    
    # Execution results
    total_gas_fees: float = Field(..., description="Total gas fees for entire group")
    execution_time_ms: float = Field(..., description="Total execution time for group")
    
    # Rollback information
    rollback_triggered: bool = Field(..., description="True if group was rolled back")
    rollback_reason: Optional[str] = Field(None, description="Reason for rollback if triggered")
    
    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class ExecutionDeltaEvent(BaseModel):
    """
    Position deltas resulting from operation execution.
    
    Captures the granular position changes from each operation for
    detailed position tracking and reconciliation.
    
    Logged by: ExecutionManager (after each operation)
    File: logs/{correlation_id}/{pid}/events/execution_deltas.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Source operation
    source_operation_id: str = Field(..., description="Operation that generated these deltas")
    operation_type: str = Field(..., description="Operation type")
    
    # Deltas with context
    deltas: List[Dict[str, Any]] = Field(..., description="Position deltas with full context")
    # Example: [
    #   {position_key: "binance:BaseToken:BTC", delta_amount: 1.0, source: "trade", price: 50000.0, fee: 25.0},
    #   {position_key: "binance:BaseToken:USDT", delta_amount: -50025.0, source: "trade", price: 50000.0, fee: 0.0}
    # ]
    
    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class ReconciliationEvent(BaseModel):
    """
    Reconciliation result from PositionUpdateHandler.
    
    Tracks the comparison between simulated and real positions in the
    tight loop reconciliation process.
    
    Logged by: PositionUpdateHandler
    File: logs/{correlation_id}/{pid}/events/reconciliations.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Reconciliation context
    trigger_source: str = Field(
        ..., 
        description="'venue_manager' (tight loop) or 'position_refresh' (discovery)"
    )
    reconciliation_type: str = Field(..., description="'tight_loop' or 'position_discovery'")
    
    # Reconciliation results
    success: bool = Field(..., description="True if positions match within tolerance")
    
    # Position comparison
    simulated_positions: Dict[str, float] = Field(..., description="position_key -> simulated amount")
    real_positions: Dict[str, float] = Field(..., description="position_key -> real amount")
    mismatches: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="List of mismatches: {position_key, simulated, real, diff, percentage}"
    )
    
    # Retry information
    retry_attempt: Optional[int] = Field(None, description="Retry attempt number (if retrying)")
    max_retries: Optional[int] = Field(None, description="Maximum retry attempts allowed")
    
    # Execution deltas applied
    execution_deltas_applied: Optional[List[Dict]] = Field(
        None,
        description="Execution deltas that were applied before reconciliation"
    )
    
    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class TightLoopExecutionEvent(BaseModel):
    """
    ExecutionManager tight loop orchestration event.
    
    Tracks the Order → Execution → Reconciliation cycle for each order
    in the tight loop.
    
    Logged by: ExecutionManager
    File: logs/{correlation_id}/{pid}/events/tight_loop_executions.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Batch context
    batch_id: str = Field(..., description="Batch identifier for group of orders")
    order_number: int = Field(..., description="Order N in batch")
    total_orders: int = Field(..., description="Total orders in batch (M)")
    
    # Order identification
    order_id: str = Field(..., description="Order being processed")
    operation_id: str = Field(..., description="Operation identifier")
    
    # Execution results
    execution_success: bool = Field(..., description="True if execution succeeded")
    execution_status: str = Field(..., description="Execution status")
    
    # Reconciliation results
    reconciliation_success: bool = Field(..., description="True if reconciliation succeeded")
    reconciliation_attempts: int = Field(..., description="Number of reconciliation attempts")
    
    # Retry information
    retry_attempts: int = Field(0, description="Number of retry attempts")
    max_retries: int = Field(3, description="Maximum retry attempts allowed")
    
    # Timing
    execution_time_ms: float = Field(..., description="Execution duration")
    reconciliation_time_ms: float = Field(..., description="Reconciliation duration")
    total_time_ms: float = Field(..., description="Total tight loop duration")
    
    # System failure
    system_failure_triggered: bool = Field(False, description="True if system failure was triggered")
    failure_reason: Optional[str] = Field(None, description="Reason for system failure")
    
    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class EventLoggingOperationEvent(BaseModel):
    """
    EventLogger operational event (meta-logging).
    
    Tracks the EventLogger's own operations for debugging logging issues.
    
    Logged by: EventLogger / DomainEventLogger
    File: logs/{correlation_id}/{pid}/events/event_logger_operations.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Operation details
    operation_type: str = Field(
        ..., 
        description="'publish', 'flush', 'rotate', 'export', 'error'"
    )
    event_type: str = Field(..., description="Type of domain event being logged")
    
    # Operation results
    success: bool = Field(..., description="True if operation succeeded")
    events_count: int = Field(..., description="Number of events processed")
    file_path: str = Field(..., description="File path where events were written")
    
    # Error information
    error_code: Optional[str] = Field(None, description="Error code if operation failed")
    error_message: Optional[str] = Field(None, description="Error message if operation failed")
    
    # Performance
    duration_ms: Optional[float] = Field(None, description="Operation duration in milliseconds")
    
    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)


class StrategyDecision(BaseModel):
    """
    Strategy decision event.
    
    Captures strategy decision-making process and reasoning.
    
    Logged by: StrategyManager
    File: logs/{correlation_id}/{pid}/events/strategy_decisions.jsonl
    """
    timestamp: str = Field(..., description="Engine timestamp (ISO format)")
    real_utc_time: str = Field(..., description="Actual UTC time when logged")
    correlation_id: str = Field(..., description="Run correlation ID")
    pid: int = Field(..., description="Process ID")
    
    # Decision context
    decision_type: str = Field(
        ..., 
        description="'entry', 'exit', 'rebalance', 'hold', 'emergency_exit'"
    )
    trigger_source: str = Field(..., description="What triggered this decision")
    
    # Decision results
    orders_generated: int = Field(..., description="Number of orders generated")
    action_taken: str = Field(..., description="Action description")
    
    # Reasoning
    reasoning: str = Field(..., description="Human-readable decision reasoning")
    market_conditions: Dict[str, Any] = Field(
        default_factory=dict,
        description="Market conditions at decision time"
    )
    portfolio_state: Dict[str, Any] = Field(
        default_factory=dict,
        description="Portfolio state at decision time"
    )
    
    # Risk assessment
    risk_level: Optional[str] = Field(None, description="Risk level: low, medium, high, critical")
    constraints_violated: List[str] = Field(default_factory=list, description="Any constraints violated")
    
    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)

