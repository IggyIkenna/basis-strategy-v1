# Cursor Rules for Basis Strategy Project

## Business Case Context

### **Product Overview**
This is a live and backtesting framework for multiple web3 and CEX trading strategies focused on **yield generation through staking and funding rates with optional leverage**. Think Ethena-style strategy enhanced with:
- **Share Classes**: USDT and ETH share classes for client investments
- **Dynamic Rebalancing**: Maximum capital allocation to strategies minus withdrawal buffer
- **Multiple Strategy Modes**: Several modes per share class (weighted average or client-selected)

### **Product Offering**
- Clients invest in either **USDT share class** or **ETH share class**
- Strategy dynamically rebalances to ensure maximum capital allocated to active strategies
- Multiple strategy modes available (weighting/selection approach TBD)
- **Fully automated** with web UI access

### **Architecture Philosophy**
- **Common architecture** for live and backtesting (easy testing)
- Some divergences allowed for messaging and data simulations in backtest mode
- Backtest mode uses historical data and simulations
- Live mode uses real-time APIs and executions

### **Development Roadmap**
1. **Current Goal**: 100% working, tested, and deployed **backtesting system**
2. **Phase 2**: Simulate full e2e workflows in staging env with small capital
3. **Final Quality Gate**: Live trading on full capital deployment

### **Key Strategies**
- Pure lending (AAVE, Morpho, etc.)
- Basis trading (funding rate arbitrage)
- Leveraged staking with optional hedging
- Market-neutral strategies
- Cross-venue liquidity optimization

## Mandatory Actions (ALWAYS Required)
- **Update docs/** when making breaking changes to config, data, codebase, backend, or frontend
- **Check docs/ consistency** - ensure all docs reference the same logic and don't conflict
- **Run test suite** after changes to ensure everything still works
- **Use actual current date** when updating documentation - run `date` command to get the real current date, never use assumed or old dates
- **Check downstream usage** when adjusting config (adding/removing fields)
- **Update frontend/backend/tests** that use the config changes
- **Check data/ usage** when changing data files or business logic
- **Update filenames and business logic** when data is added/removed
- **Update README files** when making changes to their respective directories
- **Follow instructions** in README files (tests/README.md, docs/README.md, etc.)
- **Update directory-specific READMEs** when changing structure, processes, or requirements
- **Validate** that README instructions still work after changes
- **Restart backend server** before running quality gates or long-running tests (see docs/QUALITY_GATES.md)

## Testing Requirements
- **MANDATORY**: Every completed task MUST include minimum 80% unit test coverage
- **Target**: 80% unit/integration coverage, 100% e2e coverage
- **Run test suite** in tests/ at the end of every set of changes
- Follow the testing instructions in tests/README.md
- Ensure all tests pass before considering changes complete
- If tests fail, fix the issues before proceeding
- No task is complete without comprehensive tests

## Code Quality Rules
- Use Pydantic for all data validation
- Follow the new YAML-based config structure (modes/venues/scenarios)
- All components must use the new config system
- Tests must validate the new architecture, not legacy patterns

## Refactoring Rules
- **NEVER facilitate backward compatibility during refactors** - this introduces confusion and technical debt
- When refactoring, break things cleanly and update all references
- If something needs to be preserved, document it explicitly as a migration requirement
- Prefer clean breaks over maintaining legacy support

## Documentation Rules
- Keep docs/ as the single source of truth
- Update docs/ first, then implement
- If implementation differs from docs/, update docs/ to match reality
- **NEVER create summary docs** - they waste context and become stale. Update existing docs instead
- When adding timestamps, dates, or "last updated" fields to docs, **MANDATORY** to run `date` command first to get the accurate current date

## Canonical Architecture Rules
- **REFERENCE_ARCHITECTURE_CANONICAL.md** is the single source of truth for all architectural principles
- When conflicts arise, consult canonical source hierarchy:
  1. REFERENCE_ARCHITECTURE_CANONICAL.md (highest authority)
  2. MODES.md (strategy mode definitions)
  3. VENUE_ARCHITECTURE.md (venue-specific patterns)
  4. Component specs (docs/specs/)
  5. Guide docs (WORKFLOW_GUIDE.md, etc.)
  6. Task files (.cursor/tasks/)
- For detailed ADR history, reference ARCHITECTURAL_DECISION_RECORDS.md
- All component implementations must follow patterns in REFERENCE_ARCHITECTURE_CANONICAL.md

## DRY Principle Rules
- **NEVER duplicate content** across multiple documentation files
- **SINGLE SOURCE OF TRUTH** - Each piece of information should exist in exactly one place
- **CROSS-REFERENCE, DON'T DUPLICATE** - Use references to other documents instead of copying content
- **FOCUSED DOCUMENTS** - Each document should have a clear, specific scope and purpose
- **WHEN IN DOUBT, REFERENCE** - If unsure whether to duplicate or reference, always choose to reference
- **DOCUMENT SCOPE CLEARLY** - Each document should explicitly state what it covers and what it doesn't
- **MAINTAIN REFERENCES** - Keep cross-references up-to-date when documents change
- **VIOLATION DETECTION** - If you find duplicated content, consolidate it into a single source and add cross-references

## Configuration Rules
- **NO DUPLICATION** - Each config should have a single source of truth

## Server Management Rules
- **Use `./platform.sh backtest`** to start backend in backtest mode
- **Use `./platform.sh stop-local`** to stop running servers before restarting
- **If commands hang or timeout**, restart the server and try again
- **Check server status** with `ps aux | grep python` if needed

## Quality Gate Integration Rules
- **NO ORPHANED QUALITY GATE TESTS** - All quality gate scripts MUST be integrated into `run_quality_gates.py`
- **Command Line Integration** - Every quality gate test must be runnable via command line arguments
- **Category Organization** - All tests must be organized into logical categories (docs, strategy, components, etc.)
- **Isolation Support** - Tests must support isolated execution via `--category` flags
- **Validation**: Before creating any new quality gate script, verify it's integrated into `run_quality_gates.py`
